% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/RcppExports.R
\name{fast_matrix_decomposition}
\alias{fast_matrix_decomposition}
\alias{fMatChol}
\alias{fMatLU}
\alias{fMatQR}
\alias{fMatSVD}
\alias{fMatEigen}
\title{Functions to do the decomposition by leveraging Intel MKL through RcppEigen}
\usage{
fMatChol(X)

fMatLU(X)

fMatQR(X)

fMatSVD(X)

fMatEigen(X)
}
\arguments{
\item{X}{The input matrix.}

\item{permutation_matrix}{Whether the permutation matrix is outputted.}

\item{economical}{Whether to use economical SVD.}
}
\description{
`fMatChol` performs the Cholesky decomposition of the matrix `X`,
 i.e., `X = L L^T`, where `L` is a lower triangular matrix with real
 and positive diagonal entries, and `L^T` is the transpose of `L`.
`fMatLU` performs the LU decomposition of the matrix `X`, namely, `X = PLU`,
 where `L` is a lower triangular matrix with unit diagonal entries,
 `U` is an upper triangular matrix and `P` is a permutation matrix.
`fMatQR` performs the QR decomposition of the matrix `X`, i.e., `X = QR`,
 where `Q` is an orthogonal matrix and `R` is an upper triangular matrix.
`fMatSVD` performs the singular value decomposition (SVD) of the matrix `X`, namely, `X = U D V^T`,
 where `U` and `V` are orthogonal matrices and `D` is a diagonal matrix.
`fMatEigen` performs the eigenvalue decomposition of the matrix `X`,
 i.e., `X = V D V^(-1)`, where 'V' is a matrix whose columns are the eigenvectors of 'X',
 and 'D' is a diagonal matrix whose entries are the corresponding eigenvalues of 'X'.
 `fMatEigen` returns a list of objects with two elements:  'values' and 'vectors',
 which are respectively the eigenvalues and eigenvectors of 'X'.
}
\examples{
m <- matrix(c(5,1,1,3),2,2)
fMatChol(m)
all.equal(fMatChol(m), chol(m)) # It's the same to R

X <- matrix(rnorm(9), 3, 3)
luRes <- fMatLU(X)
solve(luRes$P) \%*\% luRes$L \%*\% luRes$U # X = P^(-1) L U

qrRes <- fMatQQ(X)
qrRes$Q \%*\% qrRes$R # X = Q R

hilbert <- function(n) { i <- 1:n; 1 / outer(i - 1, i, "+") }
X <- hilbert(9)[, 1:6]
(svdRes <- fMatSVD(X))
D <- diag(as.vector(svdRes$d))
svdRes$u[ , 1:6] \%*\% D \%*\% t(svdRes$v) #  X = U D V'
t(svdRes$u[ , 1:6]) \%*\% X \%*\% svdRes$v #  D = U' X V

X <- hilbert(9)
eigenRes <- fMatEigen(X)
Re(eigenRes$vectors \%*\% diag(eigenRes$values) \%*\% solve(eigenRes$vectors)) # X = V D V^(-1)
}
