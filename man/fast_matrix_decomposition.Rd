% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/RcppExports.R
\name{fast_matrix_decomposition}
\alias{fast_matrix_decomposition}
\alias{fMatChol}
\alias{fMatLu}
\alias{fMatQr}
\alias{fMatSvd}
\alias{fMatEigen}
\title{Functions to do the decomposition by leveraging Intel MKL}
\usage{
fMatChol(X)

fMatLu(X)

fMatQr(X)

fMatSvd(X)

fMatEigen(X)
}
\arguments{
\item{X}{A matrix to perform decomposition.}

\item{permutation_matrix}{Whether the permutation matrix is outputted.}

\item{economical}{Whether to use economical SVD.}
}
\description{
Functions to do the decomposition by leveraging Intel MKL
}
\examples{
m <- matrix(c(5,1,1,3),2,2)
fMatChol(m)
all.equal(fMatChol(m), chol(m)) # It's the same to R
fMatChol(m, FALSE) # lower CHOL matrix

X <- matrix(rnorm(9), 3, 3)
luRes <- fMatLu(X)
solve(luRes$P) \%*\% luRes$L \%*\% luRes$U # X = P^(-1) L U

hilbert <- function(n) { i <- 1:n; 1 / outer(i - 1, i, "+") }
X <- hilbert(9)[, 1:6]
qrRes <- fMatQr(X)
qrRes$Q \%*\% qrRes$R # X = Q R

(svdRes <- fMatSvd(X))
D <- diag(as.vector(svdRes$d))
svdRes$u[ , 1:6] \%*\% D \%*\% t(svdRes$v) #  X = U D V'
t(svdRes$u[ , 1:6]) \%*\% X \%*\% svdRes$v #  D = U' X V

X <- hilbert(9)
eigenRes <- fMatEigen(X)
Re(eigenRes$vectors \%*\% diag(eigenRes$values) \%*\% solve(eigenRes$vectors)) # X = V D V^(-1)
}
