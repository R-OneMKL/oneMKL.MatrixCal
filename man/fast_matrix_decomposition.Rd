% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/RcppExports.R
\name{fast_matrix_decomposition}
\alias{fast_matrix_decomposition}
\alias{fMatChol}
\alias{fMatLU}
\alias{fMatQR}
\alias{fMatEigen}
\alias{fMatSVD}
\title{Functions to do the decomposition by leveraging Intel MKL through RcppEigen}
\usage{
fMatChol(X)

fMatLU(X)

fMatQR(X, with_permutation_matrix = FALSE)

fMatEigen(X, is_X_symmetric = FALSE)

fMatSVD(X)
}
\arguments{
\item{X}{The input matrix.}

\item{with_permutation_matrix}{A logical variable indicating whether
the QR decomposition is performed with a permutation matrix `P` outputted.}

\item{is_X_symmetric}{A logical variable indicating whether the input matrix `X` is symmetric.
Better computational performance is expected if the matrix is symmetric.}
}
\description{
\describe{
\item{\strong{fMatChol}}{This function performs the Cholesky decomposition of the matrix `X`,
 i.e., `X = L L^T`, where `L` is a lower triangular matrix with real
 and positive diagonal entries, and `L^T` is the transpose of `L`.}
\item{\strong{fMatLU}}{This function performs the LU decomposition of the matrix `X`, namely, `PX = LU`,
 where `L` is a lower triangular matrix with unit diagonal entries,
 `U` is an upper triangular matrix and `P` is a permutation matrix.}
\item{\strong{fMatQR}}{This function performs the QR decomposition of the matrix `X`, i.e., `X = QR`,
 where `Q` is an orthogonal matrix and `R` is an upper triangular matrix.
 If `with_permutation_matrix` = TRUE, it will output a permutation matrix `P` as well.
 The decomposition will be `XP = QR` which the algorithm is more stable than the one without a permutation matrix.}
\item{\strong{fMatSVD}}{This function performs the singular value decomposition (SVD) of the matrix `X`, namely, `X = U D V^T`,
 where `U` and `V` are orthogonal matrices and `D` is a diagonal matrix.}
\item{\strong{fMatEigen}}{This function performs the eigenvalue decomposition of the matrix `X`,
 i.e., `X = V D V^(-1)`, where 'V' is a matrix whose columns are the eigenvectors of 'X',
 and 'D' is a diagonal matrix whose entries are the corresponding eigenvalues of 'X'.}
\item{\strong{fMatEigen}}{This function returns a list of objects with two elements:  'values' and 'vectors',
 which are respectively the eigenvalues and eigenvectors of 'X'.
 If `is_X_symmetric` = TRUE, only the real part will be outputted.}
}
}
\examples{
hilbert <- function(n) { i <- 1:n; 1 / outer(i - 1, i, "+") }
# Cholesky decomposition
X <- hilbert(16)
fMatChol(X)
all.equal(fMatChol(X), chol(X)) # It's the same to R

# LU Decomposition
luRes <- fMatLU(X)
fMatInv(luRes$P) \%*\% luRes$L \%*\% luRes$U # X = P^(-1) L U

# QR Decomposition
qrRes <- fMatQR(X)
qrRes$Q \%*\% qrRes$R # X = Q R

# QR Decomposition with Permutation matrix
qrRes <- fMatQR(X, TRUE)
qrRes$Q \%*\% qrRes$R \%*\% fMatInv(qrRes$P) # X = Q R P^{-1}

# Eigen Decomposition
eigenRes <- fMatEigen(X)
Re(eigenRes$vectors \%*\% diag(eigenRes$values) \%*\% solve(eigenRes$vectors)) # X = V D V^(-1)

# Eigen Decomposition for the symmetric matrix
eigenRes2 <- fMatEigen(X, TRUE)
eigenRes2$vectors \%*\% diag(eigenRes2$values) \%*\% fMatInv(eigenRes2$vectors)

# SVD Decomposition
Z <- hilbert(9)[, 1:6]
(svdRes <- fMatSVD(Z))
svdRes$U[ , 1:6] \%*\% diag(svdRes$d) \%*\% t(svdRes$V) #  Z = U D V'
t(svdRes$U[ , 1:6]) \%*\% X \%*\% svdRes$V #  D = U' Z V
}
