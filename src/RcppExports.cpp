// Generated by using Rcpp::compileAttributes() -> do not edit by hand
// Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#include <oneMKL.h>
#include <RcppEigen.h>
#include <Rcpp.h>

using namespace Rcpp;

#ifdef RCPP_USE_GLOBAL_ROSTREAM
Rcpp::Rostream<true>&  Rcpp::Rcout = Rcpp::Rcpp_cout_get();
Rcpp::Rostream<false>& Rcpp::Rcerr = Rcpp::Rcpp_cerr_get();
#endif

// fMatChol
Eigen::MatrixXd fMatChol(const Eigen::Map<Eigen::MatrixXd> X);
RcppExport SEXP _oneMKL_MatrixCal_fMatChol(SEXP XSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< const Eigen::Map<Eigen::MatrixXd> >::type X(XSEXP);
    rcpp_result_gen = Rcpp::wrap(fMatChol(X));
    return rcpp_result_gen;
END_RCPP
}
// fMatLU
Rcpp::List fMatLU(const Eigen::Map<Eigen::MatrixXd> X);
RcppExport SEXP _oneMKL_MatrixCal_fMatLU(SEXP XSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< const Eigen::Map<Eigen::MatrixXd> >::type X(XSEXP);
    rcpp_result_gen = Rcpp::wrap(fMatLU(X));
    return rcpp_result_gen;
END_RCPP
}
// fMatQR
Rcpp::List fMatQR(const Eigen::Map<Eigen::MatrixXd> X, bool with_permutation_matrix);
RcppExport SEXP _oneMKL_MatrixCal_fMatQR(SEXP XSEXP, SEXP with_permutation_matrixSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< const Eigen::Map<Eigen::MatrixXd> >::type X(XSEXP);
    Rcpp::traits::input_parameter< bool >::type with_permutation_matrix(with_permutation_matrixSEXP);
    rcpp_result_gen = Rcpp::wrap(fMatQR(X, with_permutation_matrix));
    return rcpp_result_gen;
END_RCPP
}
// fMatEigen
Rcpp::List fMatEigen(const Eigen::Map<Eigen::MatrixXd> X, bool is_X_symmetric);
RcppExport SEXP _oneMKL_MatrixCal_fMatEigen(SEXP XSEXP, SEXP is_X_symmetricSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< const Eigen::Map<Eigen::MatrixXd> >::type X(XSEXP);
    Rcpp::traits::input_parameter< bool >::type is_X_symmetric(is_X_symmetricSEXP);
    rcpp_result_gen = Rcpp::wrap(fMatEigen(X, is_X_symmetric));
    return rcpp_result_gen;
END_RCPP
}
// fMatSVD
Rcpp::List fMatSVD(const Eigen::Map<Eigen::MatrixXd> X);
RcppExport SEXP _oneMKL_MatrixCal_fMatSVD(SEXP XSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< const Eigen::Map<Eigen::MatrixXd> >::type X(XSEXP);
    rcpp_result_gen = Rcpp::wrap(fMatSVD(X));
    return rcpp_result_gen;
END_RCPP
}
// fMatProd
Eigen::MatrixXd fMatProd(const Eigen::Map<Eigen::MatrixXd> X, Rcpp::NumericMatrix Y, bool is_X_symmetric);
RcppExport SEXP _oneMKL_MatrixCal_fMatProd(SEXP XSEXP, SEXP YSEXP, SEXP is_X_symmetricSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< const Eigen::Map<Eigen::MatrixXd> >::type X(XSEXP);
    Rcpp::traits::input_parameter< Rcpp::NumericMatrix >::type Y(YSEXP);
    Rcpp::traits::input_parameter< bool >::type is_X_symmetric(is_X_symmetricSEXP);
    rcpp_result_gen = Rcpp::wrap(fMatProd(X, Y, is_X_symmetric));
    return rcpp_result_gen;
END_RCPP
}
// fMatTransProd
Eigen::MatrixXd fMatTransProd(const Eigen::Map<Eigen::MatrixXd> X, Rcpp::NumericMatrix Y, bool is_X_symmetric);
RcppExport SEXP _oneMKL_MatrixCal_fMatTransProd(SEXP XSEXP, SEXP YSEXP, SEXP is_X_symmetricSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< const Eigen::Map<Eigen::MatrixXd> >::type X(XSEXP);
    Rcpp::traits::input_parameter< Rcpp::NumericMatrix >::type Y(YSEXP);
    Rcpp::traits::input_parameter< bool >::type is_X_symmetric(is_X_symmetricSEXP);
    rcpp_result_gen = Rcpp::wrap(fMatTransProd(X, Y, is_X_symmetric));
    return rcpp_result_gen;
END_RCPP
}
// fMatSolve
Eigen::MatrixXd fMatSolve(const Eigen::Map<Eigen::MatrixXd> X, const Eigen::Map<Eigen::MatrixXd> Y, bool is_sym_pd, bool is_invertible);
RcppExport SEXP _oneMKL_MatrixCal_fMatSolve(SEXP XSEXP, SEXP YSEXP, SEXP is_sym_pdSEXP, SEXP is_invertibleSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< const Eigen::Map<Eigen::MatrixXd> >::type X(XSEXP);
    Rcpp::traits::input_parameter< const Eigen::Map<Eigen::MatrixXd> >::type Y(YSEXP);
    Rcpp::traits::input_parameter< bool >::type is_sym_pd(is_sym_pdSEXP);
    Rcpp::traits::input_parameter< bool >::type is_invertible(is_invertibleSEXP);
    rcpp_result_gen = Rcpp::wrap(fMatSolve(X, Y, is_sym_pd, is_invertible));
    return rcpp_result_gen;
END_RCPP
}
// fMatInv
Eigen::MatrixXd fMatInv(const Eigen::Map<Eigen::MatrixXd> X, bool is_sym_pd);
RcppExport SEXP _oneMKL_MatrixCal_fMatInv(SEXP XSEXP, SEXP is_sym_pdSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< const Eigen::Map<Eigen::MatrixXd> >::type X(XSEXP);
    Rcpp::traits::input_parameter< bool >::type is_sym_pd(is_sym_pdSEXP);
    rcpp_result_gen = Rcpp::wrap(fMatInv(X, is_sym_pd));
    return rcpp_result_gen;
END_RCPP
}
// fMatPseudoInv
Eigen::MatrixXd fMatPseudoInv(const Eigen::Map<Eigen::MatrixXd> X);
RcppExport SEXP _oneMKL_MatrixCal_fMatPseudoInv(SEXP XSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< const Eigen::Map<Eigen::MatrixXd> >::type X(XSEXP);
    rcpp_result_gen = Rcpp::wrap(fMatPseudoInv(X));
    return rcpp_result_gen;
END_RCPP
}
// fMatLeastSquare
Eigen::MatrixXd fMatLeastSquare(const Eigen::Map<Eigen::MatrixXd> X, const Eigen::Map<Eigen::VectorXd> Y, bool stable, bool is_X_full_rank);
RcppExport SEXP _oneMKL_MatrixCal_fMatLeastSquare(SEXP XSEXP, SEXP YSEXP, SEXP stableSEXP, SEXP is_X_full_rankSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< const Eigen::Map<Eigen::MatrixXd> >::type X(XSEXP);
    Rcpp::traits::input_parameter< const Eigen::Map<Eigen::VectorXd> >::type Y(YSEXP);
    Rcpp::traits::input_parameter< bool >::type stable(stableSEXP);
    Rcpp::traits::input_parameter< bool >::type is_X_full_rank(is_X_full_rankSEXP);
    rcpp_result_gen = Rcpp::wrap(fMatLeastSquare(X, Y, stable, is_X_full_rank));
    return rcpp_result_gen;
END_RCPP
}
// fMatAdd
Eigen::MatrixXd fMatAdd(const Eigen::Map<Eigen::MatrixXd> X, const Eigen::Map<Eigen::MatrixXd> Y);
RcppExport SEXP _oneMKL_MatrixCal_fMatAdd(SEXP XSEXP, SEXP YSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< const Eigen::Map<Eigen::MatrixXd> >::type X(XSEXP);
    Rcpp::traits::input_parameter< const Eigen::Map<Eigen::MatrixXd> >::type Y(YSEXP);
    rcpp_result_gen = Rcpp::wrap(fMatAdd(X, Y));
    return rcpp_result_gen;
END_RCPP
}
// fMatSubtract
Eigen::MatrixXd fMatSubtract(const Eigen::Map<Eigen::MatrixXd> X, const Eigen::Map<Eigen::MatrixXd> Y);
RcppExport SEXP _oneMKL_MatrixCal_fMatSubtract(SEXP XSEXP, SEXP YSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< const Eigen::Map<Eigen::MatrixXd> >::type X(XSEXP);
    Rcpp::traits::input_parameter< const Eigen::Map<Eigen::MatrixXd> >::type Y(YSEXP);
    rcpp_result_gen = Rcpp::wrap(fMatSubtract(X, Y));
    return rcpp_result_gen;
END_RCPP
}
// fMatRowSum
Eigen::MatrixXd fMatRowSum(const Eigen::Map<Eigen::MatrixXd> X);
RcppExport SEXP _oneMKL_MatrixCal_fMatRowSum(SEXP XSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< const Eigen::Map<Eigen::MatrixXd> >::type X(XSEXP);
    rcpp_result_gen = Rcpp::wrap(fMatRowSum(X));
    return rcpp_result_gen;
END_RCPP
}
// fMatColSum
Eigen::MatrixXd fMatColSum(const Eigen::Map<Eigen::MatrixXd> X);
RcppExport SEXP _oneMKL_MatrixCal_fMatColSum(SEXP XSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< const Eigen::Map<Eigen::MatrixXd> >::type X(XSEXP);
    rcpp_result_gen = Rcpp::wrap(fMatColSum(X));
    return rcpp_result_gen;
END_RCPP
}
// fMatRowMin
Eigen::MatrixXd fMatRowMin(const Eigen::Map<Eigen::MatrixXd> X);
RcppExport SEXP _oneMKL_MatrixCal_fMatRowMin(SEXP XSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< const Eigen::Map<Eigen::MatrixXd> >::type X(XSEXP);
    rcpp_result_gen = Rcpp::wrap(fMatRowMin(X));
    return rcpp_result_gen;
END_RCPP
}
// fMatColMin
Eigen::MatrixXd fMatColMin(const Eigen::Map<Eigen::MatrixXd> X);
RcppExport SEXP _oneMKL_MatrixCal_fMatColMin(SEXP XSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< const Eigen::Map<Eigen::MatrixXd> >::type X(XSEXP);
    rcpp_result_gen = Rcpp::wrap(fMatColMin(X));
    return rcpp_result_gen;
END_RCPP
}
// fMatRowMax
Eigen::MatrixXd fMatRowMax(const Eigen::Map<Eigen::MatrixXd> X);
RcppExport SEXP _oneMKL_MatrixCal_fMatRowMax(SEXP XSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< const Eigen::Map<Eigen::MatrixXd> >::type X(XSEXP);
    rcpp_result_gen = Rcpp::wrap(fMatRowMax(X));
    return rcpp_result_gen;
END_RCPP
}
// fMatColMax
Eigen::MatrixXd fMatColMax(const Eigen::Map<Eigen::MatrixXd> X);
RcppExport SEXP _oneMKL_MatrixCal_fMatColMax(SEXP XSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< const Eigen::Map<Eigen::MatrixXd> >::type X(XSEXP);
    rcpp_result_gen = Rcpp::wrap(fMatColMax(X));
    return rcpp_result_gen;
END_RCPP
}
// fMatDet
double fMatDet(const Eigen::Map<Eigen::MatrixXd> X);
RcppExport SEXP _oneMKL_MatrixCal_fMatDet(SEXP XSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< const Eigen::Map<Eigen::MatrixXd> >::type X(XSEXP);
    rcpp_result_gen = Rcpp::wrap(fMatDet(X));
    return rcpp_result_gen;
END_RCPP
}
// fMatRank
double fMatRank(const Eigen::Map<Eigen::MatrixXd> X);
RcppExport SEXP _oneMKL_MatrixCal_fMatRank(SEXP XSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< const Eigen::Map<Eigen::MatrixXd> >::type X(XSEXP);
    rcpp_result_gen = Rcpp::wrap(fMatRank(X));
    return rcpp_result_gen;
END_RCPP
}
// fMatRCond
double fMatRCond(const Eigen::Map<Eigen::MatrixXd> X);
RcppExport SEXP _oneMKL_MatrixCal_fMatRCond(SEXP XSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< const Eigen::Map<Eigen::MatrixXd> >::type X(XSEXP);
    rcpp_result_gen = Rcpp::wrap(fMatRCond(X));
    return rcpp_result_gen;
END_RCPP
}
// getMKLVersion
std::string getMKLVersion();
RcppExport SEXP _oneMKL_MatrixCal_getMKLVersion() {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    rcpp_result_gen = Rcpp::wrap(getMKLVersion());
    return rcpp_result_gen;
END_RCPP
}
// setMKLThreads
int setMKLThreads(int nThreads);
RcppExport SEXP _oneMKL_MatrixCal_setMKLThreads(SEXP nThreadsSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< int >::type nThreads(nThreadsSEXP);
    rcpp_result_gen = Rcpp::wrap(setMKLThreads(nThreads));
    return rcpp_result_gen;
END_RCPP
}
// getMKLThreads
int getMKLThreads();
RcppExport SEXP _oneMKL_MatrixCal_getMKLThreads() {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    rcpp_result_gen = Rcpp::wrap(getMKLThreads());
    return rcpp_result_gen;
END_RCPP
}

static const R_CallMethodDef CallEntries[] = {
    {"_oneMKL_MatrixCal_fMatChol", (DL_FUNC) &_oneMKL_MatrixCal_fMatChol, 1},
    {"_oneMKL_MatrixCal_fMatLU", (DL_FUNC) &_oneMKL_MatrixCal_fMatLU, 1},
    {"_oneMKL_MatrixCal_fMatQR", (DL_FUNC) &_oneMKL_MatrixCal_fMatQR, 2},
    {"_oneMKL_MatrixCal_fMatEigen", (DL_FUNC) &_oneMKL_MatrixCal_fMatEigen, 2},
    {"_oneMKL_MatrixCal_fMatSVD", (DL_FUNC) &_oneMKL_MatrixCal_fMatSVD, 1},
    {"_oneMKL_MatrixCal_fMatProd", (DL_FUNC) &_oneMKL_MatrixCal_fMatProd, 3},
    {"_oneMKL_MatrixCal_fMatTransProd", (DL_FUNC) &_oneMKL_MatrixCal_fMatTransProd, 3},
    {"_oneMKL_MatrixCal_fMatSolve", (DL_FUNC) &_oneMKL_MatrixCal_fMatSolve, 4},
    {"_oneMKL_MatrixCal_fMatInv", (DL_FUNC) &_oneMKL_MatrixCal_fMatInv, 2},
    {"_oneMKL_MatrixCal_fMatPseudoInv", (DL_FUNC) &_oneMKL_MatrixCal_fMatPseudoInv, 1},
    {"_oneMKL_MatrixCal_fMatLeastSquare", (DL_FUNC) &_oneMKL_MatrixCal_fMatLeastSquare, 4},
    {"_oneMKL_MatrixCal_fMatAdd", (DL_FUNC) &_oneMKL_MatrixCal_fMatAdd, 2},
    {"_oneMKL_MatrixCal_fMatSubtract", (DL_FUNC) &_oneMKL_MatrixCal_fMatSubtract, 2},
    {"_oneMKL_MatrixCal_fMatRowSum", (DL_FUNC) &_oneMKL_MatrixCal_fMatRowSum, 1},
    {"_oneMKL_MatrixCal_fMatColSum", (DL_FUNC) &_oneMKL_MatrixCal_fMatColSum, 1},
    {"_oneMKL_MatrixCal_fMatRowMin", (DL_FUNC) &_oneMKL_MatrixCal_fMatRowMin, 1},
    {"_oneMKL_MatrixCal_fMatColMin", (DL_FUNC) &_oneMKL_MatrixCal_fMatColMin, 1},
    {"_oneMKL_MatrixCal_fMatRowMax", (DL_FUNC) &_oneMKL_MatrixCal_fMatRowMax, 1},
    {"_oneMKL_MatrixCal_fMatColMax", (DL_FUNC) &_oneMKL_MatrixCal_fMatColMax, 1},
    {"_oneMKL_MatrixCal_fMatDet", (DL_FUNC) &_oneMKL_MatrixCal_fMatDet, 1},
    {"_oneMKL_MatrixCal_fMatRank", (DL_FUNC) &_oneMKL_MatrixCal_fMatRank, 1},
    {"_oneMKL_MatrixCal_fMatRCond", (DL_FUNC) &_oneMKL_MatrixCal_fMatRCond, 1},
    {"_oneMKL_MatrixCal_getMKLVersion", (DL_FUNC) &_oneMKL_MatrixCal_getMKLVersion, 0},
    {"_oneMKL_MatrixCal_setMKLThreads", (DL_FUNC) &_oneMKL_MatrixCal_setMKLThreads, 1},
    {"_oneMKL_MatrixCal_getMKLThreads", (DL_FUNC) &_oneMKL_MatrixCal_getMKLThreads, 0},
    {NULL, NULL, 0}
};

RcppExport void R_init_oneMKL_MatrixCal(DllInfo *dll) {
    R_registerRoutines(dll, NULL, CallEntries, NULL, NULL);
    R_useDynamicSymbols(dll, FALSE);
}
