# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Functions to do the decomposition by leveraging Intel oneMKL
#'
#' @param x A matrix to perform decomposition.
#' @param upper A Boolean value to indicate the output matrix is a upper matrix. False will return a lower matrix.
#' @rdname fast_matrix_decomposition
#' @name fast_matrix_decomposition
#' @examples
#' m <- matrix(c(5,1,1,3),2,2)
#' fMatChol(m)
#' all.equal(fMatChol(m), chol(m)) # It's the same to R
#' fMatChol(m, FALSE) # lower CHOL matrix
#'
#' hilbert <- function(n) { i <- 1:n; 1 / outer(i - 1, i, "+") }
#' X <- hilbert(9)[, 1:6]
#' (s <- fMatSvd(X))
#' D <- diag(as.vector(s$d))
#' s$u[ , 1:6] %*% D %*% t(s$v) #  X = U D V'
#' t(s$u[ , 1:6]) %*% X %*% s$v #  D = U' X V
#'
#' fMatEigen(cbind(c(1,-1), c(-1,1)), TRUE)
#' fMatEigen(cbind(c(1,-1), c(-1,1)), FALSE) # Same, but different datatype
#'
#' X <- matrix(rnorm(9), 3, 3)
#' res <- fMatLu(X, TRUE)
#' # Note that L is generally not lower-triangular when permutation_matrix = FALSE
#' res$P %*% res$L %*% res$U # X = P' L U
#'
#' schurRes <- fMatSchur(X)
#' # Note that Schur decomposition is not unique in general.
#' schurRes$U %*% schurRes$S %*% t(schurRes$U) # X = U S U'
#'
#' qrRes <- fMatQr(X)
#' qrRes$Q %*% qrRes$R # X = Q R
#' @export
fMatChol <- function(x, upper = TRUE) {
    .Call('_oneMKL_fMatChol', PACKAGE = 'oneMKL.MatrixCal', x, upper)
}

#' @param economical Whether to use economical SVD.
#' @name fast_matrix_decomposition
#' @export
fMatSvd <- function(x, economical = FALSE) {
    .Call('_oneMKL_fMatSvd', PACKAGE = 'oneMKL.MatrixCal', x, economical)
}

#' @param is_symmetric Whether the matrix is symmetric.
#' @name fast_matrix_decomposition
#' @export
fMatEigen <- function(x, is_symmetric = FALSE) {
    .Call('_oneMKL_fMatEigen', PACKAGE = 'oneMKL.MatrixCal', x, is_symmetric)
}

#' @param permutation_matrix Whether the permutation matrix is outputted.
#' @name fast_matrix_decomposition
#' @export
fMatLu <- function(x, permutation_matrix = FALSE) {
    .Call('_oneMKL_fMatLu', PACKAGE = 'oneMKL.MatrixCal', x, permutation_matrix)
}

#' @name fast_matrix_decomposition
#' @export
fMatSchur <- function(x) {
    .Call('_oneMKL_fMatSchur', PACKAGE = 'oneMKL.MatrixCal', x)
}

#' @name fast_matrix_decomposition
#' @export
fMatQr <- function(x, permutation_matrix = FALSE, economical = FALSE) {
    .Call('_oneMKL_fMatQr', PACKAGE = 'oneMKL.MatrixCal', x, permutation_matrix, economical)
}

#' Functions to use MKL to do the matrix calculations
#'
#' @param x,y matrices
#' @return The result matrices
#'
#' @examples
#' x <- matrix(rnorm(1e4), 100)
#' y <- matrix(rnorm(1e2), 100)
#' z <- matrix(rnorm(1e4), 100)
#' XtX <- fMatProd(t(x), x)
#' XtX2 <- fMatTransProd(x, x)
#' all.equal(XtX, XtX2) # TRUE
#' invXtX <- fMatInv(XtX)
#' fMatAdd(x, z) # x + z
#' fMatSubtract(x, z) # x - z
#' fMatSumDiffSquared(x, z) # sum((x-z)^2)
#'
#' A <- matrix(c(7,6,4,8,10,11,12,9,3,5,1,2), 3, 4)
#' A %*% fMatPseudoInv(A) # => very close to identity matrix
#' @rdname fast_matrix_ops
#' @name fast_matrix_ops
#' @export
fMatProd <- function(x, y) {
    .Call('_oneMKL_fMatProd', PACKAGE = 'oneMKL.MatrixCal', x, y)
}

#' @name fast_matrix_ops
#' @export
fMatTransProd <- function(x, y) {
    .Call('_oneMKL_fMatTransProd', PACKAGE = 'oneMKL.MatrixCal', x, y)
}

#' @param is_sym_pd Whether the input matrix is symmetric/Hermitian positive definite.
#'   If the matrix is symmetric/Hermitian positive definite, enable this will be faster.
#' @name fast_matrix_ops
#' @export
fMatInv <- function(x, is_sym_pd = FALSE) {
    .Call('_oneMKL_fMatInv', PACKAGE = 'oneMKL.MatrixCal', x, is_sym_pd)
}

#' @name fast_matrix_ops
#' @export
fMatPseudoInv <- function(x) {
    .Call('_oneMKL_fMatPseudoInv', PACKAGE = 'oneMKL.MatrixCal', x)
}

#' @name fast_matrix_ops
#' @export
fMatAdd <- function(x, y) {
    .Call('_oneMKL_fMatAdd', PACKAGE = 'oneMKL.MatrixCal', x, y)
}

#' @name fast_matrix_ops
#' @export
fMatSubtract <- function(x, y) {
    .Call('_oneMKL_fMatSubtract', PACKAGE = 'oneMKL.MatrixCal', x, y)
}

#' @name fast_matrix_ops
#' @export
fMatSumDiffSquared <- function(x, y) {
    .Call('_oneMKL_fMatSumDiffSquared', PACKAGE = 'oneMKL.MatrixCal', x, y)
}

#' @name fast_matrix_ops
#' @export
fMatDet <- function(x) {
    .Call('_oneMKL_fMatDet', PACKAGE = 'oneMKL.MatrixCal', x)
}

mkl_real_solve <- function(a, b, tol) {
    .Call('_oneMKL_mkl_real_solve', PACKAGE = 'oneMKL.MatrixCal', a, b, tol)
}

mkl_cmpl_solve <- function(a, b) {
    .Call('_oneMKL_mkl_cmpl_solve', PACKAGE = 'oneMKL.MatrixCal', a, b)
}

#' Function to get the version of Intel MKL
#'
#' @return The version of Intel MKL
#' @examples
#' getMKLVersion()
#' @export
getMKLVersion <- function() {
    .Call('_oneMKL_getMKLVersion', PACKAGE = 'oneMKL.MatrixCal')
}

#' Function to get/set the number of threads used in Intel MKL
#'
#' @param nThreads The number of threads you want to use in Intel MKL.
#' @return The number of threads.
#'
#' @examples
#' getMKLThreads() # Default is the number of CPUs cores on your PC
#'
#' \dontrun{
#' setMKLThreads(1)
#' getMKLThreads() # 1
#' }
#' @name mkl_threads
#' @export
setMKLThreads <- function(nThreads) {
    .Call('_oneMKL_setMKLThreads', PACKAGE = 'oneMKL.MatrixCal', nThreads)
}

#' @name mkl_threads
#' @export
getMKLThreads <- function() {
    .Call('_oneMKL_getMKLThreads', PACKAGE = 'oneMKL.MatrixCal')
}

