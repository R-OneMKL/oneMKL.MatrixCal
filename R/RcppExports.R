# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Functions to do the decomposition by leveraging Intel MKL
#'
#' @param X A matrix to perform decomposition.
#' @rdname fast_matrix_decomposition
#' @name fast_matrix_decomposition
#' @examples
#' m <- matrix(c(5,1,1,3),2,2)
#' fMatChol(m)
#' all.equal(fMatChol(m), chol(m)) # It's the same to R
#' fMatChol(m, FALSE) # lower CHOL matrix
#'
#' X <- matrix(rnorm(9), 3, 3)
#' luRes <- fMatLu(X)
#' solve(luRes$P) %*% luRes$L %*% luRes$U # X = P^(-1) L U
#'
#' qrRes <- fMatQr(X)
#' qrRes$Q %*% qrRes$R # X = Q R
#'
#' hilbert <- function(n) { i <- 1:n; 1 / outer(i - 1, i, "+") }
#' X <- hilbert(9)[, 1:6]
#' (svdRes <- fMatSvd(X))
#' D <- diag(as.vector(svdRes$d))
#' svdRes$u[ , 1:6] %*% D %*% t(svdRes$v) #  X = U D V'
#' t(svdRes$u[ , 1:6]) %*% X %*% svdRes$v #  D = U' X V
#'
#' X <- hilbert(9)
#' eigenRes <- fMatEigen(X)
#' Re(eigenRes$vectors %*% diag(eigenRes$values) %*% solve(eigenRes$vectors)) # X = V D V^(-1)
#' @export
fMatChol <- function(X) {
    .Call('_oneMKL_MatrixCal_fMatChol', PACKAGE = 'oneMKL.MatrixCal', X)
}

#' @param permutation_matrix Whether the permutation matrix is outputted.
#' @name fast_matrix_decomposition
#' @export
fMatLu <- function(X) {
    .Call('_oneMKL_MatrixCal_fMatLu', PACKAGE = 'oneMKL.MatrixCal', X)
}

#' @name fast_matrix_decomposition
#' @export
fMatQr <- function(X) {
    .Call('_oneMKL_MatrixCal_fMatQr', PACKAGE = 'oneMKL.MatrixCal', X)
}

#' @param economical Whether to use economical SVD.
#' @name fast_matrix_decomposition
#' @export
fMatSvd <- function(X) {
    .Call('_oneMKL_MatrixCal_fMatSvd', PACKAGE = 'oneMKL.MatrixCal', X)
}

#' @name fast_matrix_decomposition
#' @export
fMatEigen <- function(X) {
    .Call('_oneMKL_MatrixCal_fMatEigen', PACKAGE = 'oneMKL.MatrixCal', X)
}

#' Functions that use oneMKL for fast matrix calculations
#'
#' @param X,Y matrices
#' @return The result matrices
#'
#' @examples
#' x <- matrix(rnorm(1e4), 100)
#' y <- matrix(rnorm(1e2), 100)
#' z <- matrix(rnorm(1e4), 100)
#' XtX <- fMatProd(t(x), x)
#' XtX2 <- fMatTransProd(x, x)
#' all.equal(XtX, XtX2) # TRUE
#' invXtX <- fMatInv(XtX)
#' fMatAdd(x, z) # x + z
#' fMatSubtract(x, z) # x - z
#' fMatRowSum(x) # rowSums(x)
#' fMatRowMin(x) # apply(x, 1, min)
#' fMatRowMax(x) # apply(x, 1, max)
#' fMatColMin(x) # apply(x, 2, min)
#' fMatColMax(x) # apply(x, 2, max)
#' fMatRank(x)
#' @rdname fast_matrix_ops
#' @name fast_matrix_ops
#' @export
fMatProd <- function(X, Y) {
    .Call('_oneMKL_MatrixCal_fMatProd', PACKAGE = 'oneMKL.MatrixCal', X, Y)
}

#' @name fast_matrix_ops
#' @export
fMatTransProd <- function(X, Y) {
    .Call('_oneMKL_MatrixCal_fMatTransProd', PACKAGE = 'oneMKL.MatrixCal', X, Y)
}

#' @param is_invertible specify whether to enable faster computation of the linear model solution
#'   by disabling the use of rcond, iterative refinement, and equilibration.
#' @param is_sym_pd specific whether the input matrix is symmetric/Hermitian positive definite.
#'   Enabling this option can result in faster computation if the matrix satisfies these properties.
#' @name fast_matrix_ops
#' @export
fMatSolve <- function(X, Y, is_sym_pd = FALSE, is_invertible = FALSE) {
    .Call('_oneMKL_MatrixCal_fMatSolve', PACKAGE = 'oneMKL.MatrixCal', X, Y, is_sym_pd, is_invertible)
}

#' @name fast_matrix_ops
#' @export
fMatInv <- function(X, is_sym_pd = FALSE) {
    .Call('_oneMKL_MatrixCal_fMatInv', PACKAGE = 'oneMKL.MatrixCal', X, is_sym_pd)
}

#' @name fast_matrix_ops
#' @export
fMatAdd <- function(X, Y) {
    .Call('_oneMKL_MatrixCal_fMatAdd', PACKAGE = 'oneMKL.MatrixCal', X, Y)
}

#' @name fast_matrix_ops
#' @export
fMatSubtract <- function(X, Y) {
    .Call('_oneMKL_MatrixCal_fMatSubtract', PACKAGE = 'oneMKL.MatrixCal', X, Y)
}

#' @name fast_matrix_ops
#' @export
fMatRowSum <- function(X) {
    .Call('_oneMKL_MatrixCal_fMatRowSum', PACKAGE = 'oneMKL.MatrixCal', X)
}

#' @name fast_matrix_ops
#' @export
fMatColSum <- function(X) {
    .Call('_oneMKL_MatrixCal_fMatColSum', PACKAGE = 'oneMKL.MatrixCal', X)
}

#' @name fast_matrix_ops
#' @export
fMatRowMin <- function(X) {
    .Call('_oneMKL_MatrixCal_fMatRowMin', PACKAGE = 'oneMKL.MatrixCal', X)
}

#' @name fast_matrix_ops
#' @export
fMatColMin <- function(X) {
    .Call('_oneMKL_MatrixCal_fMatColMin', PACKAGE = 'oneMKL.MatrixCal', X)
}

#' @name fast_matrix_ops
#' @export
fMatRowMax <- function(X) {
    .Call('_oneMKL_MatrixCal_fMatRowMax', PACKAGE = 'oneMKL.MatrixCal', X)
}

#' @name fast_matrix_ops
#' @export
fMatColMax <- function(X) {
    .Call('_oneMKL_MatrixCal_fMatColMax', PACKAGE = 'oneMKL.MatrixCal', X)
}

#' @name fast_matrix_ops
#' @export
fMatDet <- function(X) {
    .Call('_oneMKL_MatrixCal_fMatDet', PACKAGE = 'oneMKL.MatrixCal', X)
}

#' @name fast_matrix_ops
#' @export
fMatRank <- function(X) {
    .Call('_oneMKL_MatrixCal_fMatRank', PACKAGE = 'oneMKL.MatrixCal', X)
}

#' @name fast_matrix_ops
#' @export
fMatRCond <- function(X) {
    .Call('_oneMKL_MatrixCal_fMatRCond', PACKAGE = 'oneMKL.MatrixCal', X)
}

#' Function to get the version of Intel MKL
#'
#' @return The version of Intel MKL
#' @examples
#' getMKLVersion()
#' @export
getMKLVersion <- function() {
    .Call('_oneMKL_MatrixCal_getMKLVersion', PACKAGE = 'oneMKL.MatrixCal')
}

#' Function to get/set the number of threads used in Intel MKL
#'
#' @param nThreads The number of threads you want to use in Intel MKL.
#' @return The number of threads.
#'
#' @examples
#' getMKLThreads() # Default is the number of CPUs cores on your PC
#'
#' \dontrun{
#' setMKLThreads(1)
#' getMKLThreads() # 1
#' }
#' @name mkl_threads
#' @export
setMKLThreads <- function(nThreads) {
    .Call('_oneMKL_MatrixCal_setMKLThreads', PACKAGE = 'oneMKL.MatrixCal', nThreads)
}

#' @name mkl_threads
#' @export
getMKLThreads <- function() {
    .Call('_oneMKL_MatrixCal_getMKLThreads', PACKAGE = 'oneMKL.MatrixCal')
}

